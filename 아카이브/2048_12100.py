# 이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다.
# 상, 하, 좌, 우 이동시 각 숫자 블록들은 갈 수 있는 한 최대한 멀리 이동한다.
# 이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다.
# 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다.
# (실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다)
# 0은 빈 칸을 나타낸다.

# 위로 드래그시 위에부터 우선순위, 아래로 드래그시 아래부터 우선순위, ...
# 따라서 이미 합쳐진 블록에 대한 우선순위는 각 드래그 방향에서 시작하여 부여. (이동하려고 하는 쪽의 칸이 먼저 합쳐진다.)

# 최대 5번 이동해서 얻을 수 있는 가장 큰 값을 구하라.

#######################################################################################################

# BFS 문제.
# 상하좌우 기동

#######################################################################################################

from collections import deque

# 환경 설정
n = int(input())
board = [list(map(int, input().split())) for _ in range(n)]

# 기동 - 좌 우 상 하
dxs = [1, -1, 0 ,0]
dys = [0, 0, 1, -1]

